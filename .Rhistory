a_uniform_reference <- rep((1/n_reference), n_reference)
x_reference <- rbind(functions_reference,a_uniform_reference)
reference_based <- (-1)*suppressMessages(KL(x_reference, test.na = TRUE, unit = "log", est.prob = NULL, epsilon = 1e-05))
# Abundance-based redundancy
x_abundance <- rbind(functions_sample,abundance)
abundance_based <- (-1)*suppressMessages(KL(x_abundance, test.na = TRUE, unit = "log", est.prob = NULL, epsilon = 1e-05))
}
}
fredundancy(functions, abundance, 10)
abundance
# Taxon-based redundancy
# Sample based
functions_sample <- functions
a_uniform_sample <- rep(1/length(abundance), length(abundance))
x_sample <- rbind(functions_sample,a_uniform_sample)
sample_based <- (-1)*suppressMessages(KL(x, test.na = TRUE, unit = "log", est.prob = NULL, epsilon = 1e-05))
a_uniform_sample
# Taxon-based redundancy
# Sample based
functions_sample <- functions
functions_sample
x_sample <- rbind(functions_sample,a_uniform_sample)
x_sample
sum(functions_sample)
sum(a_uniform_sample)
fredundancy <- function(functions, abundance, n_reference){
# Normalize function vector
if(sum(functions) !=1){
functions <- functions/sum(functions)
}
# Check if abundances sum up to one
if(sum(abundance) !=1){
print("Error abundances to not sum up to one")
}
else {
# Taxon-based redundancy
# Sample based
functions_sample <- functions
a_uniform_sample <- rep(1/length(abundance), length(abundance))
x_sample <- rbind(functions_sample,a_uniform_sample)
sample_based <- (-1)*suppressMessages(KL(x_sample, test.na = TRUE, unit = "log", est.prob = NULL, epsilon = 1e-05))
# Reference based redundancy
#functions that can be performed
functions_gz <- functions[functions > 0]
#amount of species that cannot produce it but are in the reference
zero_f <- rep(0, n_reference - length(functions_gz))
functions_reference <- c(functions_gz, zero_f)
a_uniform_reference <- rep((1/n_reference), n_reference)
x_reference <- rbind(functions_reference,a_uniform_reference)
reference_based <- (-1)*suppressMessages(KL(x_reference, test.na = TRUE, unit = "log", est.prob = NULL, epsilon = 1e-05))
# Abundance-based redundancy
x_abundance <- rbind(functions_sample,abundance)
abundance_based <- (-1)*suppressMessages(KL(x_abundance, test.na = TRUE, unit = "log", est.prob = NULL, epsilon = 1e-05))
}
}
fredundancy(functions, abundance, 10)
abundance_based
fredundancy <- function(functions, abundance, n_reference){
# Normalize function vector
if(sum(functions) != 1){
functions <- functions / sum(functions)
}
# Check if abundances sum up to one
if(sum(abundance) != 1){
print("Error abundances do not sum up to one")
} else {
# Taxon-based redundancy
# Sample-based
functions_sample <- functions
a_uniform_sample <- rep(1/length(abundance), length(abundance))
x_sample <- rbind(functions_sample, a_uniform_sample)
sample_based <- (-1) * suppressMessages(KL(x_sample, test.na = TRUE, unit = "log", est.prob = NULL, epsilon = 1e-05))
# Reference-based redundancy
functions_gz <- functions[functions > 0]
zero_f <- rep(0, n_reference - length(functions_gz))
functions_reference <- c(functions_gz, zero_f)
a_uniform_reference <- rep(1/n_reference, n_reference)
x_reference <- rbind(functions_reference, a_uniform_reference)
reference_based <- (-1) * suppressMessages(KL(x_reference, test.na = TRUE, unit = "log", est.prob = NULL, epsilon = 1e-05))
# Abundance-based redundancy
x_abundance <- rbind(functions_sample, abundance)
abundance_based <- (-1) * suppressMessages(KL(x_abundance, test.na = TRUE, unit = "log", est.prob = NULL, epsilon = 1e-05))
# Return the results as a list
return(list(
sample_based = sample_based,
reference_based = reference_based,
abundance_based = abundance_based
))
}
}
fredundancy(functions, abundance, 10)
redundancy <- fredundancy(functions, abundance, 10)
redundancy$sample_based
View(redundancy)
# Function
fredundancy <- function(functions, abundance, n_reference) {
# Normalize function vector if the sum is not 1
normalize_vector <- function(x) {
if (sum(x) != 1) {
return(x / sum(x))
}
return(x)
}
# Validate that abundance sums to 1
validate_abundance <- function(abundance) {
if (sum(abundance) != 1) {
stop("Error: Abundances do not sum up to 1.")
}
}
# Helper function to calculate KL divergence
calculate_kl_divergence <- function(x1, x2) {
return((-1) * suppressMessages(KL(x1, test.na = TRUE, unit = "log", est.prob = NULL, epsilon = 1e-05)))
}
# Normalize functions and check abundance
functions <- normalize_vector(functions)
validate_abundance(abundance)
# Taxon-based redundancy
# Sample-based redundancy
a_uniform_sample <- rep(1 / length(abundance), length(abundance))
x_sample <- rbind(functions, a_uniform_sample)
sample_based <- calculate_kl_divergence(x_sample, a_uniform_sample)
# Reference-based redundancy
functions_gz <- functions[functions > 0]  # Only functions > 0
zero_f <- rep(0, n_reference - length(functions_gz))  # Pad with zeros
functions_reference <- c(functions_gz, zero_f)
a_uniform_reference <- rep(1 / n_reference, n_reference)
x_reference <- rbind(functions_reference, a_uniform_reference)
reference_based <- calculate_kl_divergence(x_reference, a_uniform_reference)
# Abundance-based redundancy
x_abundance <- rbind(functions, abundance)
abundance_based <- calculate_kl_divergence(x_abundance, abundance)
# Return results as a list
return(list(
sample_based = sample_based,
reference_based = reference_based,
abundance_based = abundance_based
))
}
fredundancy(functions, abundance, 10)
a <- fredundancy(functions, abundance, 10)
a$sample_based
fredundancy <- function(functions, abundance, n_reference) {
# Normalize function vector if the sum is not 1
normalize_vector <- function(x) {
if (sum(x) != 1) {
return(x / sum(x))
}
return(x)
}
# Validate that abundance sums to 1
validate_abundance <- function(abundance) {
if (sum(abundance) != 1) {
stop("Error: Abundances do not sum up to 1.")
}
}
# Helper function to calculate KL divergence and return the numeric result
calculate_kl_divergence <- function(x1, x2) {
kl_value <- (-1) * suppressMessages(KL(x1, test.na = TRUE, unit = "log", est.prob = NULL, epsilon = 1e-05))
return(as.numeric(kl_value))  # Remove the label by converting to numeric
}
# Normalize functions and check abundance
functions <- normalize_vector(functions)
validate_abundance(abundance)
# Taxon-based redundancy
# Sample-based redundancy
a_uniform_sample <- rep(1 / length(abundance), length(abundance))
x_sample <- rbind(functions, a_uniform_sample)
sample_based <- calculate_kl_divergence(x_sample, a_uniform_sample)
# Reference-based redundancy
functions_gz <- functions[functions > 0]  # Only functions > 0
zero_f <- rep(0, n_reference - length(functions_gz))  # Pad with zeros
functions_reference <- c(functions_gz, zero_f)
a_uniform_reference <- rep(1 / n_reference, n_reference)
x_reference <- rbind(functions_reference, a_uniform_reference)
reference_based <- calculate_kl_divergence(x_reference, a_uniform_reference)
# Abundance-based redundancy
x_abundance <- rbind(functions, abundance)
abundance_based <- calculate_kl_divergence(x_abundance, abundance)
# Return results as a list
return(list(
sample_based = sample_based,
reference_based = reference_based,
abundance_based = abundance_based
))
}
fredundancy(functions, abundance, 10)
a <- fredundancy(functions, abundance, 10)
a$sample_based
x_abundance
# Abundance-based redundancy
x_abundance <- rbind(functions, abundance)
x_abundance
fredundancy <- function(functions, abundance, n_reference) {
# Normalize function vector if the sum is not 1
normalize_vector <- function(x) {
if (sum(x) != 1) {
return(x / sum(x))
}
return(x)
}
# Validate that abundance sums to 1
validate_abundance <- function(abundance) {
if (sum(abundance) != 1) {
stop("Error: Abundances do not sum up to 1.")
}
}
# Helper function to calculate KL divergence and return the numeric result
calculate_kl_divergence <- function(x1) {
kl_value <- (-1) * suppressMessages(KL(x1, test.na = TRUE, unit = "log", est.prob = NULL, epsilon = 1e-05))
return(as.numeric(kl_value))  # Remove the label by converting to numeric
}
# Normalize functions and check abundance
functions <- normalize_vector(functions)
validate_abundance(abundance)
# Taxon-based redundancy
# Sample-based redundancy
a_uniform_sample <- rep(1 / length(abundance), length(abundance))
x_sample <- rbind(functions, a_uniform_sample)
sample_based <- calculate_kl_divergence(x_sample)
# Reference-based redundancy
functions_gz <- functions[functions > 0]  # Only functions > 0
zero_f <- rep(0, n_reference - length(functions_gz))  # Pad with zeros
functions_reference <- c(functions_gz, zero_f)
a_uniform_reference <- rep(1 / n_reference, n_reference)
x_reference <- rbind(functions_reference, a_uniform_reference)
reference_based <- calculate_kl_divergence(x_reference)
# Abundance-based redundancy
x_abundance <- rbind(functions, abundance)
abundance_based <- calculate_kl_divergence(x_abundance)
# Return results as a list
return(list(
sample_based = sample_based,
reference_based = reference_based,
abundance_based = abundance_based
))
}
a <- fredundancy(functions, abundance, 10)
a
# Function
fredundancy <- function(functions, abundance, n_reference) {
# Normalize function vector if the sum is not 1
normalize_vector <- function(x) {
if (sum(x) != 1) {
return(x / sum(x))
}
return(x)
}
# Validate that abundance sums to 1
validate_abundance <- function(abundance) {
if (sum(abundance) != 1) {
stop("Error: Abundances do not sum up to 1.")
}
}
# Helper function to calculate KL divergence and return the numeric result
calculate_kl_divergence <- function(x1) {
kl_value <- (-1) * suppressMessages(KL(x1, test.na = TRUE, unit = "log", est.prob = NULL, epsilon = 1e-05))
return(as.numeric(kl_value))  # Remove the label by converting to numeric
}
# Normalize functions and check abundance
functions <- normalize_vector(functions)
validate_abundance(abundance)
# Taxon-based redundancy
# Sample-based redundancy
a_uniform_sample <- rep(1 / length(abundance), length(abundance))
x_sample <- rbind(functions, a_uniform_sample)
sample_based <- calculate_kl_divergence(x_sample)
# Reference-based redundancy
functions_gz <- functions[functions > 0]  # Only functions > 0
zero_f <- rep(0, n_reference - length(functions_gz))  # Pad with zeros
functions_reference <- c(functions_gz, zero_f)
a_uniform_reference <- rep(1 / n_reference, n_reference)
x_reference <- rbind(functions_reference, a_uniform_reference)
reference_based <- calculate_kl_divergence(x_reference)
# Abundance-based redundancy
x_abundance <- rbind(functions, abundance)
abundance_based <- calculate_kl_divergence(x_abundance)
# Interdependency abundance
abundance_I <- abundance[functions_gz>0]
# Interdependency index
x_interdependency <- rbind(functions_gz, abundance_I)
interdependency <- calculate_kl_divergence(x_interdependency)
# Return results as a list
return(list(
sample_based = sample_based,
reference_based = reference_based,
abundance_based = abundance_based,
interdependency = interdependency
))
}
a <- fredundancy(functions, abundance, 10)
a
fredundancy <- function(functions, abundance, n_reference) {
# Normalize function vector if the sum is not 1
normalize_vector <- function(x) {
if (sum(x) != 1) {
return(x / sum(x))
}
return(x)
}
# Validate that abundance sums to 1
validate_abundance <- function(abundance) {
if (sum(abundance) != 1) {
stop("Error: Abundances do not sum up to 1.")
}
}
# Helper function to calculate KL divergence and return the numeric result
calculate_kl_divergence <- function(x1, negative = TRUE) {
kl_value <- suppressMessages(KL(x1, test.na = TRUE, unit = "log", est.prob = NULL, epsilon = 1e-05))
# Optionally apply the negative sign
if (negative) {
return(-as.numeric(kl_value))  # Negative by default
} else {
return(as.numeric(kl_value))  # No negative sign for interdependency
}
}
# Normalize functions and check abundance
functions <- normalize_vector(functions)
validate_abundance(abundance)
# Taxon-based redundancy
# Sample-based redundancy
a_uniform_sample <- rep(1 / length(abundance), length(abundance))
x_sample <- rbind(functions, a_uniform_sample)
sample_based <- calculate_kl_divergence(x_sample)
# Reference-based redundancy
functions_gz <- functions[functions > 0]  # Only functions > 0
zero_f <- rep(0, n_reference - length(functions_gz))  # Pad with zeros
functions_reference <- c(functions_gz, zero_f)
a_uniform_reference <- rep(1 / n_reference, n_reference)
x_reference <- rbind(functions_reference, a_uniform_reference)
reference_based <- calculate_kl_divergence(x_reference)
# Abundance-based redundancy
x_abundance <- rbind(functions, abundance)
abundance_based <- calculate_kl_divergence(x_abundance)
# Interdependency (No negative sign here)
abundance_I <- abundance[functions_gz > 0]
x_interdependency <- rbind(functions_gz, abundance_I)
interdependency <- calculate_kl_divergence(x_interdependency, negative = FALSE)
# Return results as a list
return(list(
sample_based = sample_based,
reference_based = reference_based,
abundance_based = abundance_based,
interdependency = interdependency
))
}
a <- fredundancy(functions, abundance, 10)
a
check()
check()
devtools::check()
update.packages()
devtools::check()
devtools::check()
usethis::edit_r_environ()
devtools::check()
document()
document()
document()
document()
?fredundancy
document()
install()
document()
install()
install()
library(fredundancy)
abundance <- c(0.2, 0.1, 0.05, 0.05, 0.6)
functions <- c(0.8, 0.1, 0.05, 0.05, 0)
n_reference <- 8
a <- fredundancy(functions = functions, abundance = abundance, n_reference = NULL)
library(FunRed)
abundance <- c(0.2, 0.1, 0.05, 0.05, 0.6)
functions <- c(0.8, 0.1, 0.05, 0.05, 0)
n_reference <- 8
a <- fredundancy(functions = functions, abundance = abundance, n_reference = NULL)
install()
install()
remove.packages("Rcpp")
install.packages("Rcpp")
install()
library(FunRed)
abundance <- c(0.2, 0.1, 0.05, 0.05, 0.6)
functions <- c(0.8, 0.1, 0.05, 0.05, 0)
n_reference <- 8
a <- fredundancy(functions = functions, abundance = abundance, n_reference = NULL)
sum(abundance)
sum(functions)
# Remove zeros
abundance <- abundance[abundance > 0]
validate_abundance <- function(abundance) {
if (sum(abundance) != 1) {
stop("Error: Abundances do not sum up to 1")
}
}
abundance <- c(0.2, 0.1, 0.05, 0.05, 0.6)
functions <- c(0.8, 0.1, 0.05, 0.05, 0)
n_reference <- 8
a <- fredundancy(functions = functions, abundance = abundance, n_reference = NULL)
install()
abundance <- c(0.2, 0.1, 0.05, 0.05, 0.6)
functions <- c(0.8, 0.1, 0.05, 0.05, 0)
n_reference <- 8
a <- fredundancy(functions = functions, abundance = abundance, n_reference = NULL)
install()
library(FunRed)
abundance <- c(0.2, 0.1, 0.05, 0.05, 0.6)
functions <- c(0.8, 0.1, 0.05, 0.05, 0)
n_reference <- 8
a <- fredundancy(functions = functions, abundance = abundance, n_reference = NULL)
a
functions
# Normalize functions and check abundance
functions <- normalize_vector(functions)
validate_abundance(abundance)
functions_gz <- functions[functions > 0]
functions_gz
n_reference
zero_f <- rep(0, n_reference - length(functions_gz))  # Pad with zeros
functions_reference <- c(functions_gz, zero_f)
a_uniform_reference <- rep(1 / n_reference, n_reference)
a_uniform_reference
abundance <- c(0.2, 0.1, 0.05, 0.05, 0.6)
functions <- c(0.8, 0.1, 0.05, 0.05, 0)
n_reference <- 7
a <- fredundancy(functions = functions, abundance = abundance, n_reference = NULL)
a
# Only calculate reference-based redundancy if n_reference is provided
functions_gz <- functions[functions > 0]  # Only functions > 0
functions_gz
zero_f <- rep(0, n_reference - length(functions_gz))  # Pad with zeros
zero_f
functions_reference <- c(functions_gz, zero_f)
a_uniform_reference <- rep(1 / n_reference, n_reference)
functions_reference
a_uniform_reference <- rep(1 / n_reference, n_reference)
a_uniform_reference
x_reference <- rbind(functions_reference, a_uniform_reference)
reference_based <- calculate_kl_divergence(x_reference)
calculate_kl_divergence <- function(x1, negative = TRUE) {
kl_value <- suppressMessages(KL(x1, test.na = TRUE, unit = "log", est.prob = NULL, epsilon = 1e-05))
# Optionally apply the negative sign
if (negative) {
return(-as.numeric(kl_value))  # Negative by default
} else {
return(as.numeric(kl_value))  # No negative sign for interdependency
}
}
reference_based <- calculate_kl_divergence(x_reference)
calculate_kl_divergence <- function(x1, negative = TRUE) {
kl_value <- suppressMessages(KL(x1, test.na = TRUE, unit = "log", est.prob = NULL, epsilon = 1e-05))
# Optionally apply the negative sign
if (negative) {
return(-as.numeric(kl_value))  # Negative by default
} else {
return(as.numeric(kl_value))  # No negative sign for interdependency
}
}
reference_based <- calculate_kl_divergence(x_reference)
reference_based <- calculate_kl_divergence(x_reference)
x_reference <- rbind(functions_reference, a_uniform_reference)
reference_based <- calculate_kl_divergence(x_reference)
calculate_kl_divergence
x_reference
calculate_kl_divergence(x_reference)
library(philentropy)
calculate_kl_divergence(x_reference)
abundance <- c(0.2, 0.1, 0.05, 0.05, 0.6)
functions <- c(0.8, 0.1, 0.05, 0.05, 0)
n_reference <- 7
a <- fredundancy(functions = functions, abundance = abundance, n_reference = NULL)
library(FunRed)
abundance <- c(0.2, 0.1, 0.05, 0.05, 0.6)
functions <- c(0.8, 0.1, 0.05, 0.05, 0)
n_reference <- 7
a <- fredundancy(functions = functions, abundance = abundance, n_reference = NULL)
a
abundance <- c(0.2, 0.1, 0.05, 0.05, 0.6)
functions <- c(0.8, 0.1, 0.05, 0.05, 0)
n_reference <- 9
a <- fredundancy(functions = functions, abundance = abundance, n_reference = NULL)
a
a <- fredundancy(functions = functions, abundance = abundance, n_reference = n_reference)
a
n_reference <- 7
a <- fredundancy(functions = functions, abundance = abundance, n_reference = n_reference)
a
a <- fredundancy(functions = functions, abundance = abundance, n_reference = n_reference)
a
install()
library(FunRed)
abundance <- c(0.2, 0.1, 0.05, 0.05, 0.6)
functions <- c(0.8, 0.1, 0.05, 0.05, 0)
n_reference <- 7
a <- fredundancy(functions = functions, abundance = abundance, n_reference = n_reference)
abundance <- c(0.2, 0.1, 0.05, 0.05, 0.6)
functions <- c(0.8, 0.1, 0.05, 0.05, 0)
n_reference <- 7
a <- fredundancy(functions = functions, abundance = abundance, n_reference = n_reference)
library(FunRed)
a <- fredundancy(functions = functions, abundance = abundance, n_reference = n_reference)
a
# Interdependency
abundance_I <- abundance[functions > 0]
abundance_I
sum(abundance_I)
install()
library(FunRed)
abundance <- c(0.2, 0.1, 0.05, 0.05, 0.6)
functions <- c(0.8, 0.1, 0.05, 0.05, 0)
n_reference <- 7
a <- fredundancy(functions = functions, abundance = abundance, n_reference = n_reference)
a
